# 2.1.6. I/O 系统

UNIX I/O 系统的基本模型是一个字节序列，可以随机或按顺序访问。在一个典型的 UNIX 用户进程中，没有访问方法，也没有控制块。

不同的程序期望有不同层次的结构，但是内核并不强加给 I/O 的结构。例如，文本文件的惯例是由一个换行符（ASCII 换行符）分隔的 ASCII 字符行，但内核对这个惯例一无所知。对于大多数程序来说，该模型被进一步简化为数据字节流，或 I/O 流。正是这种单一的通用数据形式使得基于 UNIX 工具的方法得以运行[Kernighan & Pike, 1984]。来自一个程序的 I/O 流可以作为输入输入到几乎任何其他程序。(这种传统的 UNIX I/O 流不应与第八版流 I/O 系统或 System V, Release 3 STREAMS 混淆，两者都可以作为传统的 I/O 流来访问）。

## 2.1.6.1. 描述符和 I/O

UNIX 进程使用描述符来引用 I/O 流。描述符是小的无符号整数，从 open 和 socket 系统调用中获得。open 系统调用的参数是一个文件的名称和一个权限模式，以指定该文件是为读还是为写，或者是为两者打开。这个系统调用也可以用来创建一个新的、空的文件。读或写系统调用可以应用于描述符来传输数据。关闭系统调用可以用来删除任何描述符。

描述符代表内核支持的底层对象，并由特定对象类型的系统调用创建。在 4.4BSD 中，有三种对象可以用描述符表示：文件、管道和插座。

- 一个*文件*是一个至少有一个名字的线性字节阵列。一个文件存在，直到它的所有名字被明确删除，并且没有进程持有它的描述符。一个进程通过使用*open*系统调用打开一个文件的名称来获得该文件的描述符。I/O 设备作为文件被访问。

- 一个*管道*是一个线性的字节数组，就像一个文件一样，但它只作为一个 I/O 流使用，而且是单向的。它也没有名字，因此不能用 *open* 打开。相反，它是由 *pipe* 系统调用创建的，它返回两个描述符，其中一个接受输入，并按顺序可靠地发送到另一个描述符上，没有重复。系统还支持一个命名的管道或 FIFO。FIFO 的属性与管道相同，只是它出现在文件系统中；因此，它可以用 *open* 系统调用打开。两个希望进行通信的进程各自打开 FIFO。一个打开用于读取，另一个用于写入。

- 一个 *socket* 是一个用于进程间通信的暂存对象；它只在某个进程持有指向它的描述符时才存在。一个套接字是由 *socket* 系统调用创建的，该调用为它返回一个描述符。有不同种类的套接字，支持各种通信语义，如可靠的数据传递、保存消息的顺序和保存消息的边界。

在 4.2BSD 之前的系统中，管道是用文件系统实现的；当 4.2BSD 中引入套接字时，管道被重新实现为套接字。

内核为每个进程保存一个描述符表，这是一个内核用来将描述符的外部表示转换为内部表示的表。(一个进程的描述符表是由该进程的父代继承的，因此对描述符所指向的对象的访问也是继承的。进程获得描述符的主要方式是通过打开或创建一个对象，以及从父进程继承。此外，套接字IPC允许同一台机器上不相关的进程之间在消息中传递描述符。

每个有效的描述符都有一个相关的文件偏移量，从对象的开头开始，以字节为单位。读和写操作从这个偏移量开始，在每次数据传输后都会更新。对于允许随机访问的对象，文件偏移量也可以通过 lseek 系统调用来设置。普通文件允许随机访问，一些设备也是如此。管道和套接字则不允许。

当一个进程终止时，内核会回收该进程所使用的所有描述符。如果该进程持有对某一对象的最终引用，该对象的管理人将被通知，以便它可以做任何必要的清理动作，比如最终删除一个文件或取消一个套接字的分配。

## 2.1.6.2. 描述符管理

大多数进程在开始运行时都希望有三个描述符已经打开。这些描述符分别是0、1、2，通常被称为标准输入、标准输出和标准错误。通常，这三个描述符都由登录进程与用户的终端相关联（见第14.6节），并由用户运行的进程通过fork和exec继承。因此，程序可以通过读取标准输入来读取用户输入的内容，程序可以通过写入标准输出来向用户的屏幕发送输出。标准错误描述符也是开放的，用于错误输出，而标准输出则用于普通输出。

这些（和其他）描述符可以被映射到终端以外的对象；这种映射被称为 I/O 重定向，所有的标准 shell 都允许用户这样做。shell 可以通过关闭描述符1（标准输出）并打开所需的输出文件来产生一个新的描述符1，从而将程序的输出指向一个文件。同样，它也可以通过关闭描述符0并打开文件，将标准输入重定向到一个文件中。

管道允许一个程序的输出被输入到另一个程序，而不需要重写或甚至重新链接任何一个程序。源程序的描述符1（标准输出）不是被设置为写到终端，而是被设置为管道的输入描述符。同样地，汇入程序的描述符0（标准输入）被设置为引用管道的输出，而不是终端键盘。由此产生的两个进程和连接管道的集合被称为管道。管道可以是由管道连接的任意长的进程系列。

open、pipe 和 socket 系统调用会产生新的描述符，这些描述符具有最低的未使用的数字，可用于描述符。为了使管道工作，必须提供一些机制来将这些描述符映射为0和1。 dup 系统调用创建一个描述符的副本，指向同一个文件表项。新的描述符也是最低的未使用的描述符，但是如果想要的描述符先被关闭，dup可以用来做想要的映射。然而，需要注意的是：如果需要描述符1，而描述符0恰好也被关闭了，那么描述符0将成为结果。为了避免这个问题，系统提供了 dup2 系统调用；它和 dup 一样，但是它需要一个额外的参数，指定所需描述符的编号（如果所需描述符已经打开，dup2 会在重新使用它之前将其关闭）。

## 2.1.6.3. 设备

硬件设备有文件名，用户可以通过用于普通文件的相同系统调用来访问。内核可以区分一个设备的特殊文件或特殊文件，并可以确定它指的是什么设备，但大多数进程不需要做这种判断。终端机、打印机和磁带机都是像 4.4BSD 磁盘文件那样被访问的字节流。因此，设备的依赖性和特殊性被尽可能的保留在内核中，即使在内核中，大部分也被隔离在设备驱动中。

硬件设备可分为结构化和非结构化；它们分别被称为块状或字符设备。进程通常通过文件系统中的特殊文件访问设备。对这些文件的 I/O 操作由驻在内核的软件模块处理，称为设备驱动程序。大多数网络通信硬件设备只能通过进程间通信设施访问，在文件系统名称空间中没有特殊文件，因为原始插座接口提供了一个比特殊文件更自然的接口。

结构化或块状设备的典型代表是磁盘和磁带，也包括大多数随机存取设备。内核支持在面向块的结构化设备上进行读-改-写类型的缓冲操作，以允许后者以完全随机的字节地址方式被读写，就像普通文件一样。文件系统是在块设备上创建的。

非结构化设备是那些不支持块结构的设备。熟悉的非结构化设备是通信线路、光栅绘图仪和无缓冲的磁带和磁盘。非结构化设备通常支持大块 I/O 传输。

非结构化的文件被称为字符设备，因为第一个被实现的是终端设备驱动程序。这些设备的驱动的内核接口被证明对其他非块状结构的设备很方便。

设备特殊文件是由 mknod 系统调用创建的。有一个额外的系统调用，ioctl，用于操作特殊文件的基础设备参数。每个设备可以进行的操作是不同的。这个系统调用允许访问设备的特殊特性，而不是重载其他系统调用的语义。例如，在磁带机上有一个 ioctl 来写一个磁带末尾的标记，而不是有一个特殊的或修改过的写版本。

## 2.1.6.4. Socket IPC

4.2BSD 内核引入了一种比管道更灵活的 IPC 机制，以套接字为基础。套接字是一个由描述符所指的通信端点，就像一个文件或管道。两个进程可以各自创建一个套接字，然后连接这两个端点以产生一个可靠的字节流。一旦连接起来，套接字的描述符可以被进程读取或写入，就像后者对管道所做的那样。套接字的透明性允许内核将一个进程的输出重定向到另一台机器上的另一个进程的输入。管道和套接字之间的一个主要区别是，管道需要一个共同的父进程来建立通信通道。而套接字之间的连接可以由两个不相关的进程建立，可能驻留在不同的机器上。

System V通过 FIFO（也被称为命名的管道）提供本地的进程间通信。FIFO 作为文件系统中的一个对象出现，不相关的进程可以通过它打开并发送数据，就像它们通过管道进行通信一样。因此，FIFO 不需要一个共同的父体来设置它们；它们可以在一对进程启动和运行后被连接。与套接字不同，FIFO 只能在本地机器上使用；它们不能用于不同机器上的进程之间的通信。FIFO 在4.4BSD 中实现，只是因为它们是 POSIX.1 标准的要求。它们的功能是套接字接口的一个子集。

套接字机制需要对传统的 UNIX I/O 系统调用进行扩展，以提供相关的命名和连接语义。开发人员没有重载现有的接口，而是在不改变现有接口的情况下使用了现有的接口，并设计了新的接口来处理增加的语义。读和写系统调用被用于字节流类型的连接，但增加了六个新的系统调用，以允许发送和接收有地址的消息，如网络数据报。写信息的系统调用包括 send、sendto和sendmsg。读取消息的系统调用包括 recv、recvfrom和recvmsg。现在回想起来，每个类中的前两个都是其他类的特例；recvfrom 和 sendto 可能应该分别作为 recvmsg 和 sendmsg 的库接口加入。

## 2.1.6.5. 散射/聚集I/O

除了传统的读写系统调用外，4.2BSD 还引入了做分散/聚集I/O的能力。分散输入使用 readv 系统调用，允许一个单一的读被放在几个不同的缓冲区中。反之，writeev 系统调用允许在一个单一的原子写中写入几个不同的缓冲区。进程不是像读和写那样传递一个缓冲区和长度参数，而是传递一个指向缓冲区和长度数组的指针，以及一个描述数组大小的计数。

这种设施允许在进程地址空间的不同部分的缓冲区被原子化地写入，而不需要将它们复制到一个连续的缓冲区。在底层抽象是基于记录的情况下，原子写入是必要的，比如磁带机在每次写入请求时输出一个磁带块。能够把一个请求读到几个不同的缓冲区也是很方便的（比如把记录头读到一个地方，把数据读到另一个地方）。尽管一个应用程序可以通过将数据读入一个大的缓冲区，然后将这些碎片复制到它们预定的目的地来模拟分散数据的能力，但在这种情况下，内存到内存的复制成本往往会使受影响的应用程序的运行时间增加一倍以上。

正如 send 和 recv 可以作为 sendto和recvfrom 的库接口来实现一样，我们也可以用 readv 来模拟 read，用 writeev 来模拟 write。然而，读和写的使用频率非常高，因此模拟它们的额外成本是不值得的。

## 2.1.6.6. 支持多个文件系统

随着网络计算的扩展，同时支持本地和远程文件系统变得很理想。为了简化对多个文件系统的支持，开发人员在内核中增加了一个新的虚拟节点或 vnode 接口。从 vnode 接口输出的一系列操作看起来很像以前由本地文件系统支持的文件系统操作。然而，它们可能被广泛的文件系统类型所支持:

- 基于本地磁盘的文件系统
- 使用各种远程文件系统协议导入的文件
- 只读 CD-ROM 文件系统
- 提供特殊用途接口的文件系统 - 例如，`/proc`文件系统

4.4BSD 的少数变种，如 FreeBSD，允许在文件系统首次被 mount 系统调用引用时动态加载文件系统。第6.5节描述了 vnode 接口；第6.6节描述了其辅助支持例程；第6.7节描述了几个特殊用途的文件系统。
