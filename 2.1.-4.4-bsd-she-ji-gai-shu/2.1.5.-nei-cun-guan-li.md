# 2.1.5. 内存管理

每个进程都有自己的私有地址空间。地址空间最初被划分为三个逻辑段：文本、数据和堆栈。文本段是只读的，包含程序的机器指令。数据和堆栈段既可读又可写。数据段包含程序的初始化和未初始化的数据部分，而堆栈段包含应用程序的运行时堆栈。在大多数机器上，堆栈段是由内核在进程执行时自动扩展的。一个进程可以通过系统调用来扩展或收缩其数据段，而一个进程只有在其文本段的内容与文件系统的数据重叠时，或在调试时才能改变其文本段的大小。子进程的段的初始内容是父进程的段的重复。

进程地址空间的全部内容不需要为进程的执行而驻留。如果一个进程引用其地址空间的一部分，而这部分内容并不驻留在主内存中，系统会将必要的信息分页到内存中。当系统资源稀缺时，系统使用两级方法来维持可用资源。如果有适量的内存可用，如果这些资源最近没有被使用，系统将从进程中拿走内存资源。如果出现严重的资源短缺，系统将诉诸于将进程的整个上下文交换到二级存储。系统所做的需求分页和交换对进程来说是有效透明的。然而，一个进程可以向系统提供关于预期的未来内存利用率的建议，作为一种性能帮助。

## 2.1.5.1. BSD 内存管理的设计决定

支持大的稀疏地址空间、映射文件和共享内存是 4.2BSD 的一个要求。我们指定了一个接口，叫做 mmap，它允许不相关的进程请求将文件共享映射到他们的地址空间。如果多个进程将同一个文件映射到他们的地址空间，那么一个进程对文件的地址空间部分的改变就会反映在其他进程映射的区域，以及文件本身。最终，4.2BSD 在发货时没有使用 mmap 接口，因为有其他功能的压力，比如网络。

在 4.3BSD 的工作中，mmap 接口的进一步发展继续进行。超过 40 家公司和研究小组参与了讨论，导致了在《伯克利软件架构手册》[McKusick et al, 1994]中描述的修订架构。其中有几家公司已经实现了修改后的接口[Gingell et al, 1987]。

再一次，时间的压力使 4.3BSD 无法提供接口的实现。尽管后者本可以内置于现有的 4.3BSD 虚拟内存系统中，但开发者决定不把它放进去，因为那个实现已经有将近10年的历史了。此外，最初的虚拟内存设计是基于这样的假设：计算机内存小而昂贵，而磁盘是本地连接的，速度快，体积大，而且价格便宜。因此，虚拟内存系统的设计是以产生额外的磁盘流量为代价，节俭地使用内存。此外，4.3BSD 的实现充满了 VAX 内存管理的硬件依赖，阻碍了它对其他计算机架构的移植。最后，虚拟内存系统并不是为了支持今天越来越普遍和重要的紧密耦合的多处理器而设计的。

试图逐步改善旧的实现方式似乎注定要失败。另一方面，一个全新的设计，可以利用大内存，节省磁盘传输，并有可能在多处理器上运行。因此，虚拟内存系统在4.4BSD中被完全取代。4.4BSD的虚拟内存系统是基于Mach 2.0虚拟系统[Tevanian, 1987]，并从 Mach 2.5 和 Mach 3.0 进行了更新。它的特点是对共享的有效支持，与机器无关和与机器有关的功能的干净分离，以及（目前未使用的）多处理器支持。进程可以在其地址空间的任何地方映射文件。它们可以通过对同一文件进行共享映射来共享其地址空间的一部分。一个进程所做的改变在另一个进程的地址空间中是可见的，并且也会被写回文件本身。进程也可以要求对文件进行私有映射，这可以防止他们所做的任何改变对映射文件的其他进程可见，或被写回文件本身。

虚拟内存系统的另一个问题是，当进行系统调用时，信息被传递到内核中的方式。4.4BSD 总是把数据从进程的地址空间复制到内核的缓冲区。对于传输大量数据的读或写操作，进行复制会很耗时。一个替代复制的方法是将进程内存重新映射到内核中。4.4BSD 的内核总是复制数据，这有几个原因。

- 通常情况下，用户数据不是页面对齐的，也不是硬件页面长度的倍数。

- 如果该页被从进程中拿走，它将不再能够引用该页。一些程序依赖于缓冲区内的数据，即使这些数据已经被写入。

- 如果进程被允许保留一个页面的副本(就像目前 4.4BSD 语义中的那样)，这个页面必须被做成*copy-on-write*。一个写时拷贝的页面是一个被保护的页面，通过只读来防止被写入。如果进程试图修改该页，内核会得到一个写错。内核然后制作一个该进程可以修改的页面的副本。不幸的是，典型的进程会立即尝试向其输出缓冲区写入新的数据，迫使数据被复制。

- 当页面被重新映射到新的虚拟内存地址时，大多数内存管理硬件需要选择性地清除硬件地址转换缓存。缓存的清除往往很慢。净效果是，对于小于4到8K字节的数据块，重映射比复制要慢。

对内存映射的最大激励是访问大文件和在进程之间传递大量数据的需要。mmap 接口为这两项任务提供了一种无需复制的方式。

## 2.1.5.2. 内核内部的内存管理

内核经常对内存进行分配，这些内存只需要在一次系统调用的时间内使用。在用户进程中，这种短期内存会被分配到运行时堆栈中。因为内核的运行时堆栈是有限的，在上面分配中等大小的内存块也是不可行的。因此，这种内存必须通过一个更动态的机制来分配。例如，当系统必须翻译一个路径名时，它必须分配一个 1K 字节的缓冲区来保存该名称。其他的内存块必须比单个系统调用更持久，因此即使有空间也不能在堆栈中分配。一个例子是协议控制块，它在网络连接的整个过程中保持不变。

随着更多服务的加入，对内核中动态内存分配的需求也在增加。一个通用的内存分配器减少了在内核内编写代码的复杂性。因此，4.4BSD 内核有一个单一的内存分配器，可以被系统的任何部分使用。它有一个类似于 C 库例程 malloc 和 free 的接口，为应用程序提供内存分配[McKusick & Karels, 1988]。像 C 库接口一样，分配例程需要一个参数，指定需要的内存大小。内存请求的大小范围不受限制；然而，物理内存是被分配的，而不是分页的。free 例程需要一个指向被释放的存储的指针，但不要求被释放的内存的大小。
